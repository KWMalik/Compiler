!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALLOC_FSM	include/fsm.h	49;"	d
ALLOC_LIST	include/set.h	28;"	d
ALLOC_STATE	include/fsm.h	51;"	d
ALLOC_STATE_LINK	include/fsm.h	53;"	d
ALLOC_TREE	include/set.h	26;"	d
BIN	Makefile	/^BIN = bin$/;"	m
CAPITAL_LETTERS	include/fsm.h	/^	CAPITAL_LETTERS,$/;"	e	enum:special
CC	Makefile	/^CC = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -Iinclude\/$/;"	m
CHECK_CONDITION	include/debug.h	23;"	d
CHECK_CONDITION	include/debug.h	30;"	d
CONCAT	include/regex_parser.h	/^	CONCAT,$/;"	e	enum:operation
DEBUG	include/commons.rb.h	7;"	d
DEBUG_INIT	include/debug.h	14;"	d
DEBUG_INIT	include/debug.h	31;"	d
DEBUG_MSG	include/debug.h	24;"	d
DEBUG_MSG	include/debug.h	32;"	d
DEFINES	Makefile	/^DEFINES =$/;"	m
DIGITS	include/fsm.h	/^	DIGITS$/;"	e	enum:special
DOT	include/fsm.h	/^	DOT,$/;"	e	enum:special
EPSILON	include/fsm.h	/^	EPSILON,$/;"	e	enum:special
FOR_EACH	include/set.h	51;"	d
FSM_INCLUDE_H	include/fsm.h	2;"	d
LB	include/regex_parser.h	/^	LB,$/;"	e	enum:operation
LENaz	include/hashtable.rxg.h	5;"	d
MAXLENtokenname	include/commons.rb.h	6;"	d
MAX_ENUM	include/fsm.h	25;"	d
MAX_FILENAME	src/main.c	15;"	d	file:
MAX_LINE_LENGTH	src/main.c	14;"	d	file:
MAX_REGEX_LEN	include/regex_parser.h	12;"	d
MAX_STATES	include/regex_to_fsm.h	14;"	d
MAX_TOKENS	src/main.c	12;"	d	file:
MAX_TOKEN_LENGTH	src/main.c	13;"	d	file:
NFA_operators	src/regex_to_fsm.c	/^char NFA_operators[] = { '*', '@', '|' };$/;"	v
NONE	include/fsm.h	/^	NONE = 0,		\/\/ No special symbol$/;"	e	enum:special
OBJ	Makefile	/^OBJ = obj$/;"	m
OBJECTS	Makefile	/^OBJECTS = ${OBJ}\/fsm.o ${OBJ}\/set.o ${OBJ}\/regex_parser.o ${OBJ}\/regex_to_fsm.o ${OBJ}\/main.o$/;"	m
OR	include/regex_parser.h	/^	OR,$/;"	e	enum:operation
POP	src/regex_to_fsm.c	9;"	d	file:
PUSH	src/regex_to_fsm.c	8;"	d	file:
RB	include/regex_parser.h	/^	RB$/;"	e	enum:operation
REGEX_2_FSM_H_INCLUDED	include/regex_to_fsm.h	9;"	d
REGEX_PARSER_H_INCLUDED	include/regex_parser.h	10;"	d
SET_H_INCLUDED	include/set.h	8;"	d
SMALL_LETTERS	include/fsm.h	/^	SMALL_LETTERS,$/;"	e	enum:special
SRC	Makefile	/^SRC = src$/;"	m
STAR	include/regex_parser.h	/^	STAR,$/;"	e	enum:operation
accept	src/fsm.c	/^int accept (char c, enum special sym)$/;"	f
accept_state	include/fsm.h	/^	state_t *accept_state;$/;"	m	struct:fsm_t
c	include/fsm.h	/^	char c;				\/\/ The character for which the state link exists$/;"	m	struct:state_link_t
concat_NFA	src/fsm.c	/^int concat_NFA (fsm_t *fsm1, fsm_t *fsm2)$/;"	f
convert_range	src/regex_parser.c	/^static void convert_range (char *original_regex)$/;"	f	file:
create_NFA	src/regex_to_fsm.c	/^unsigned int create_NFA (fsm_t *fsm, char *regular_expression)$/;"	f
create_transition	src/fsm.c	/^state_link_t * create_transition (char c, enum special sym, state_t *next_state)$/;"	f
deep_copy	src/fsm.c	/^void deep_copy (fsm_t *dest, fsm_t *src)$/;"	f
delete_tree	src/set.c	/^void delete_tree (tree_t *root)$/;"	f
epsilon_set_transitions	src/fsm.c	/^void epsilon_set_transitions (tree_t *cur_states)$/;"	f
epsilon_state_transitions	src/fsm.c	/^int epsilon_state_transitions (state_t *cur_state, tree_t *set_new_states)$/;"	f
er	include/commons.rb.h	9;"	d
error_file	include/debug.h	/^FILE * error_file;$/;"	v
find	src/set.c	/^tree_t * find ( tree_t * root, state_t * addr)$/;"	f
fsm_t	include/fsm.h	/^typedef struct fsm_t$/;"	s
fsm_t	include/fsm.h	/^} fsm_t;$/;"	t	typeref:struct:fsm_t
hash_entry_linklist	include/hashtable.rxg.h	/^typedef	struct hash_entry_linklist$/;"	s
hashtable	include/hashtable.rxg.h	/^hll* hashtable[LENaz];$/;"	v
height	include/set.h	/^	unsigned int height;$/;"	m	struct:tree_t
hll	include/hashtable.rxg.h	/^	hll;$/;"	t	typeref:struct:hash_entry_linklist
hs_enhash	src/hashtable_functions.rb.c	/^char hs_enhash(char* s)$/;"	f
hs_find	src/hashtable_functions.rb.c	/^hll* hs_find(char* s)$/;"	f
hs_initialize	src/hashtable_functions.rb.c	/^void hs_initialize(void)$/;"	f
hs_insert	src/hashtable_functions.rb.c	/^hll* hs_insert(char* s)$/;"	f
id	include/commons.rb.h	/^		int id;$/;"	m	struct:symbol_table_entry
infix2postfix	src/regex_parser.c	/^void infix2postfix (char *original_regex, char *final_regex)$/;"	f
insert_concat_sym	src/regex_parser.c	/^static void insert_concat_sym (char *original_regex)$/;"	f	file:
insert_element	src/set.c	/^unsigned int insert_element (tree_t *root, state_t *addr)$/;"	f
insert_op_string	src/regex_parser.c	116;"	d	file:
insert_operator	src/regex_parser.c	/^static char * insert_operator(enum operation op, char *final_regex) $/;"	f	file:
is_final_state	include/fsm.h	/^	char is_final_state;$/;"	m	struct:state_t
is_operator	src/regex_parser.c	/^int is_operator (char c)$/;"	f
is_special_symbol	src/fsm.c	/^int is_special_symbol (char c)$/;"	f
left	include/set.h	/^	struct tree_t *left;$/;"	m	struct:tree_t	typeref:struct:tree_t::tree_t
linenumber	include/commons.rb.h	/^		int* linenumber;	\/\/ I hope to make it point to an \\$/;"	m	struct:symbol_table_entry
link_states	src/fsm.c	/^int link_states (state_t *state1, state_t *state2, char c, enum special sym)$/;"	f
links	include/fsm.h	/^	state_link_t *links;		\/\/ List of links to other states.$/;"	m	struct:state_t
list_t	include/set.h	/^typedef struct list_t$/;"	s
list_t	include/set.h	/^} list_t;$/;"	t	typeref:struct:list_t
lnext	include/hashtable.rxg.h	/^		struct hash_entry_linklist *lnext;$/;"	m	struct:hash_entry_linklist	typeref:struct:hash_entry_linklist::hash_entry_linklist
main	src/main.c	/^int main (int argc, char *argv[])$/;"	f
n_tokens	src/main.c	/^static int n_tokens = 0;$/;"	v	file:
new_states	src/fsm.c	/^void new_states (state_t *cur_state, char c, tree_t *new_states)$/;"	f
next	include/fsm.h	/^	struct state_link_t *next;		\/\/ Another state link$/;"	m	struct:state_link_t	typeref:struct:state_link_t::state_link_t
next	include/set.h	/^	struct list_t * next;$/;"	m	struct:list_t	typeref:struct:list_t::list_t
next_state	include/fsm.h	/^	struct state_t *next_state;		\/\/ The state to which it leads$/;"	m	struct:state_link_t	typeref:struct:state_link_t::state_t
op_functions	src/regex_to_fsm.c	/^int (*op_functions[]) (fsm_t *, fsm_t *) = $/;"	v
op_stack	src/regex_parser.c	/^static char op_stack[MAX_REGEX_LEN];$/;"	v	file:
op_stack_top	src/regex_parser.c	/^static int op_stack_top;		\/\/ Indicates the top most element$/;"	v	file:
operation	include/regex_parser.h	/^enum operation		$/;"	g
operators	src/regex_parser.c	/^char operators[] = { '*', '@', '|', '(', ')' };$/;"	v
pnext	include/commons.rb.h	/^		struct symbol_table_entry* pnext;$/;"	m	struct:symbol_table_entry	typeref:struct:symbol_table_entry::symbol_table_entry
push_single_char_NFA_on_stack	src/regex_to_fsm.c	/^void push_single_char_NFA_on_stack (char c, enum special sym)$/;"	f
raw_time	include/debug.h	/^time_t raw_time;$/;"	v
read_tokens	src/main.c	/^void read_tokens (FILE *fp)$/;"	f
repeat_NFA	src/fsm.c	/^int repeat_NFA (fsm_t *fsm1, fsm_t *fsm2)$/;"	f
right	include/set.h	/^	struct tree_t *right;$/;"	m	struct:tree_t	typeref:struct:tree_t::tree_t
sentry	include/hashtable.rxg.h	/^		ste *sentry;	\/\/include symbol table struct$/;"	m	struct:hash_entry_linklist
simulate_NFA	src/fsm.c	/^int simulate_NFA (fsm_t *fsm, char *str)$/;"	f
single_char_NFA	src/fsm.c	/^int single_char_NFA (fsm_t *fsm, char c, enum special sym)$/;"	f
special	include/fsm.h	/^enum special $/;"	g
special_symbols	src/fsm.c	/^char special_symbols[] = { 0, '.', '^', '$', '%', '#' };$/;"	v
st_find	src/symboltable_functions.rb.c	/^ste* st_find(char* t)$/;"	f
st_insert	src/symboltable_functions.rb.c	/^ste* st_insert(ste* const h, char* t, int y, int l)$/;"	f
st_link	src/symboltable_functions.rb.c	/^inline static void st_link(hll* n, ste* e)$/;"	f	file:
st_ninstances	src/symboltable_functions.rb.c	/^int st_ninstances(ste* e)$/;"	f
st_printentry	src/symboltable_functions.rb.c	/^inline void st_printentry(ste* e, FILE* f)$/;"	f
st_printtable	src/symboltable_functions.rb.c	/^void st_printtable(ste* const h, FILE* f)$/;"	f
stack_fsm	include/regex_to_fsm.h	/^fsm_t *stack_fsm[MAX_STATES];$/;"	v
stack_top	src/regex_to_fsm.c	/^int stack_top = 0;$/;"	v
start_state	include/fsm.h	/^	state_t start_state;$/;"	m	struct:fsm_t
state_addr	include/set.h	/^	state_t *state_addr;$/;"	m	struct:list_t
state_addr	include/set.h	/^	state_t *state_addr;$/;"	m	struct:tree_t
state_link_t	include/fsm.h	/^typedef struct state_link_t$/;"	s
state_link_t	include/fsm.h	/^} state_link_t;$/;"	t	typeref:struct:state_link_t
state_t	include/fsm.h	/^typedef struct state_t$/;"	s
state_t	include/fsm.h	/^} state_t;$/;"	t	typeref:struct:state_t
ste	include/commons.rb.h	/^	ste;$/;"	t	typeref:struct:symbol_table_entry
sym	include/fsm.h	/^	enum special sym;		\/\/ enum special type indicating the special symbol being used like (dot) $/;"	m	struct:state_link_t	typeref:enum:state_link_t::special
symbol_table_entry	include/commons.rb.h	/^typedef	struct symbol_table_entry$/;"	s
timeinfo	include/debug.h	/^struct tm * timeinfo;$/;"	v	typeref:struct:tm
token_NFA	src/main.c	/^fsm_t token_NFA[MAX_TOKENS];$/;"	v
tokenname	include/commons.rb.h	/^		char tokenname[MAXLENtokenname];$/;"	m	struct:symbol_table_entry
tokenname	include/hashtable.rxg.h	/^		char tokenname[MAXLENtokenname];$/;"	m	struct:hash_entry_linklist
tokens	src/main.c	/^char tokens[MAX_TOKENS][MAX_TOKEN_LENGTH];$/;"	v
tokentype	include/commons.rb.h	/^		int tokentype;$/;"	m	struct:symbol_table_entry
tree_t	include/set.h	/^typedef struct tree_t $/;"	s
tree_t	include/set.h	/^} tree_t;$/;"	t	typeref:struct:tree_t
tree_to_list	src/set.c	/^void tree_to_list (tree_t *tree, list_t *list)$/;"	f
union_sets	src/set.c	/^void union_sets (tree_t *set1, tree_t *set2)$/;"	f
union_sets_internal	src/set.c	/^void union_sets_internal (tree_t *set1, tree_t *set2)$/;"	f
